#include "FWCore/Framework/interface/stream/EDProducer.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/Utilities/interface/InputTag.h"

#include "DataFormats/PatCandidates/interface/PackedCandidate.h"
#include "DataFormats/PatCandidates/interface/Tau.h"

#include "CommonTools/Utils/interface/StringCutObjectSelector.h"
#include "DataFormats/Math/interface/deltaR.h"

class PFTauMerger : public edm::stream::EDProducer<> {
public:
  explicit PFTauMerger(const edm::ParameterSet & iConfig);
  virtual ~PFTauMerger() { }

  virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup) override;

private:
  
  edm::InputTag taus_;
  StringCutObjectSelector<pat::Tau, false> tausCut_;

  bool mergeTracks_;
  edm::InputTag tracks_;
  StringCutObjectSelector<pat::PackedCandidate, false> tracksCut_;

  edm::EDGetTokenT<std::vector<pat::Tau> > tauToken_;
  edm::EDGetTokenT<std::vector<pat::PackedCandidate> > trackToken_;
};


PFTauMerger::PFTauMerger(const edm::ParameterSet & iConfig) :
    taus_(iConfig.getParameter<edm::InputTag>("taus")),
    tausCut_(iConfig.existsAs<std::string>("tausCut") ? iConfig.getParameter<std::string>("tausCut") : ""),    
    mergeTracks_(iConfig.existsAs<bool>("mergeTracks") ? iConfig.getParameter<bool>("mergeTracks") : false),
    tracks_(mergeTracks_ ? iConfig.getParameter<edm::InputTag>("tracks") : edm::InputTag()),
    tracksCut_(iConfig.existsAs<std::string>("tracksCut") ? iConfig.getParameter<std::string>("tracksCut") : "")
{
  tauToken_ = consumes<std::vector<pat::Tau> >(taus_);
  trackToken_ = consumes<std::vector<pat::PackedCandidate> > (tracks_);
  produces<std::vector<pat::Tau> >();
}

void 
PFTauMerger::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) {
    edm::Handle<std::vector<pat::Tau> > taus;
    edm::Handle<std::vector<pat::PackedCandidate> > tracks;

    iEvent.getByToken(tauToken_,taus);
    if(mergeTracks_) iEvent.getByToken(trackToken_,tracks);

    std::auto_ptr<std::vector<pat::Tau> >  out(new std::vector<pat::Tau>());
    out->reserve(taus->size() + (mergeTracks_?tracks->size():0));

    // copy reco::Taus, turning on the CaloCompatibility flag if enabled and possible
    for (std::vector<pat::Tau>::const_iterator it = taus->begin(), ed = taus->end(); it != ed; ++it) {
        if(!tausCut_(*it)) continue;
	out->push_back(*it);
    }
    // merge reco::Track avoiding duplication of innerTracks
    if(mergeTracks_){
        for (size_t i = 0; i < tracks->size(); i++) {
	    pat::PackedCandidateRef track(tracks, i);
            if(!tracksCut_(*track)) continue;
            // check if it is a tau
            bool isTau = false;
            for(std::vector<pat::Tau>::const_iterator tau = taus->begin(); tau < taus->end(); tau++){
	      if(reco::deltaR(*tau->leadTrack(),*track)<0.007){
                    isTau = true;
                    break;
                }
            }
            if(isTau) continue;           
            // make a reco::Tau
            double energy = sqrt(track->p() * track->p() + 0.13957018);
            math::XYZTLorentzVector p4(track->px(), track->py(), track->pz(), energy);
	    reco::BaseTau aBaseTau(track->charge(), p4, track->vertex());
            out->push_back(pat::Tau(aBaseTau));
        }
    }

    iEvent.put(out);
}

#include "FWCore/Framework/interface/MakerMacros.h"
DEFINE_FWK_MODULE(PFTauMerger);
